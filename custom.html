<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wplace 맞춤 지점 감시기</title>
  <link rel="apple-touch-icon" sizes="180x180" href="custom favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="custom favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="custom favicon/favicon-16x16.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
  <link rel="manifest" href="custom favicon/site.webmanifest">
  <style>

.info-modal {
  display: none;
  position: fixed;
  z-index: 1500;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0);
  transition: background-color 0.3s ease;
}

.info-modal.show {
  background-color: rgba(0,0,0,0.5);
}

.info-modal.show .modal-content {
  transform: scale(1) translateY(0);
  opacity: 1;
}

.info-modal h3 {
  margin-top: 0;
  color: var(--accent);
  text-align: center;
}


.info-btn {
  position: absolute;
  top: 20px;
  left: 20px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  width: 45px;
  height: 45px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  z-index: 100;
}

/* 서버 상태 표시등 스타일 (추가할 코드) */
.server-status {
  position: absolute;
  top: 25px;
  left: 80px;
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 20px;
  padding: 8px 15px;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  cursor: default;
  z-index: 100;
}

.status-light {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: #888; /* 기본 회색 */
  transition: background-color 0.5s ease, box-shadow 0.5s ease;
}

/* 상태별 색상 정의 */
.server-status.ok .status-light {
  background-color: #28a745; /* 초록 */
  box-shadow: 0 0 8px rgba(40, 167, 69, 0.7);
}

.server-status.error .status-light {
  background-color: #ff4444; /* 빨강 */
  box-shadow: 0 0 8px rgba(255, 68, 68, 0.7);
}

.server-status.unknown .status-light {
  background-color: #ffbb33; /* 주황 */
  box-shadow: 0 0 8px rgba(255, 187, 51, 0.7);
}


/* 상태 표시등 애니메이션을 위한 부모 요소 */
.status-light-wrapper {
  position: relative;
  width: 12px;
  height: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* 퍼져나가는 애니메이션 효과 */
@keyframes pulse-animation {
  0% {
    transform: scale(1);
    opacity: 0.6;
  }
  100% {
    transform: scale(3);
    opacity: 0;
  }
}

.status-light-wrapper .pulse {
  position: absolute;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: currentColor; /* 부모의 색상을 상속받음 */
  animation: pulse-animation 1s ease-out;
  animation-fill-mode: forwards; /* 애니메이션 종료 상태 유지 */
}

/* 커스텀 툴팁(말풍선) 스타일 */
.custom-tooltip {
  position: absolute;
  bottom: -120%; /* 상태 표시등 위쪽에 위치 */
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 13px;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s ease, visibility 0.2s ease;
  z-index: 110;
}

/* 말풍선 꼬리 */
.custom-tooltip::after {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #333 transparent;
}

/* 호버 시 툴팁 보이기 */
.server-status:hover .custom-tooltip {
  opacity: 1;
  visibility: visible;
}

  .info-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.info-btn i {
  color: var(--text-color);
  font-size: 20px;
}

.info-body {
  max-height: 60vh;
  overflow-y: auto;
  font-size: 15px;
  line-height: 1.6;
  color: var(--text-color);
}

    :root {
      --frame-bg: #e6e5e5;
      --gap: 18px;
      --accent: #0055ff;
      /* 라이트 모드 색상 */
      --bg-color: #f8f9fa;
      --text-color: #111;
      --card-bg: #fff;
      --border-color: #ccc;
      --input-bg: #fff;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #e0e0e0;
      --card-bg: #2d2d2d;
      --border-color: #444;
      --input-bg: #333;
      --frame-bg: #636363;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .wrap {
      max-width: 1200px;
      margin: 28px auto;
      padding: 20px
    }

    header {
      text-align: center;
      margin-bottom: 24px
    }

    header h1 {
      font-size: 26px;
      margin: 0;
      color: var(--accent)
    }

    header p {
      font-size: 15px;
      color: var(--text-color);
      margin: 6px 0 0
    }

    .dark-mode-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      z-index: 100;
    }

    .dark-mode-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .dark-mode-toggle svg {
      width: 24px;
      height: 24px;
      color: var(--text-color);
      transition: transform 0.3s ease;
    }

    .dark-mode-toggle.rotating svg {
      transform: rotate(180deg);
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      margin-bottom: 20px;
    }

    .controls label {
      font-size: 14px;
      margin-right: 8px
    }

    .controls input {
      width: 70px;
      padding: 4px;
      font-size: 14px;
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 6px
    }

    .controls button {
      margin-right: 3px; /* 각 버튼 사이 여백 */
    }


    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap)
    }

    @media (min-width: 768px) {
      .grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
    }

    .form-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 14px;
      box-sizing: border-box;
      background: var(--input-bg);
      color: var(--text-color);
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }

    .controls input {
      width: 70px;
      padding: 4px;
      font-size: 14px;
      text-align: center;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--input-bg);
      color: var(--text-color);
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }

    .modal-content {
      background-color: var(--card-bg);
      margin: 2% auto;
      padding: 30px;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      transform: scale(0.7) translateY(-100px);
      opacity: 0;
      transition: all 0.3s ease;
    }

    .confirm-content {
      background: var(--card-bg);
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      margin: 20px;
      transform: scale(0.8) translateY(-50px);
      opacity: 0;
      transition: all 0.3s ease;
    }

    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.12)
    }

    .add-card {
      background: var(--card-bg);
      border: 2px dashed var(--border-color);
      cursor: pointer;
      justify-content: center;
      align-items: center;
      min-height: 200px;
    }

    .add-card:hover {
      border-color: var(--accent);
      background: var(--card-bg);
      opacity: 0.8;
    }

    .add-icon {
      width: 48px;
      height: 48px;
      color: var(--text-color);
      margin-bottom: 10px;
    }

    .add-text {
      color: var(--text-color);
      font-size: 16px;
    }

    .card-header {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 10px;
      min-height: 40px;
    }

    .card .meta {
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 1;
    }

    .card .meta strong {
      font-size: 16px;
      color: var(--text-color)
    }

    .card-buttons {
      position: absolute;
      top: 0;
      right: 0;
      display: flex;
      gap: 4px;
      z-index: 10;
    }

    .delete-btn, .edit-btn {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .edit-btn {
      background: #28a745;
    }

    .delete-btn:hover {
      background: #cc0000;
      transform: translateY(-1px);
    }

    .edit-btn:hover {
      background: #1e7e34;
      transform: translateY(-1px);
    }

    .goto-btn {
      background: linear-gradient(135deg, #0055ff, #0099ff);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 2px;
      text-decoration: none;
      box-shadow: 0 2px 6px rgba(0, 85, 255, 0.3);
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .goto-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 85, 255, 0.4);
    }

    .goto-btn svg {
      width: 10px;
      height: 10px;
    }

    /* 다크모드 토글 옆의 빠른 링크 버튼 */
    .quick-link-btn {
      position: absolute;
      top: 28px;
      right: 90px; /* 다크모드 버튼보다 왼쪽으로 배치 */
      background: linear-gradient(135deg, #0055ff, #0099ff);
      color: white;
      border: none;
      border-radius: 15px;
      padding: 8px 14px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      text-decoration: none;
      box-shadow: 0 2px 6px rgba(0, 85, 255, 0.3);
      transition: all 0.2s ease;
      z-index: 99;
    }
  
    .btn-export, .btn-import {
      border: none;
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 13px;
      font-weight: 500;
      color: white;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: all 0.2s ease;
      margin: 0 6px;
    }

    /* 내보내기 버튼 (초록색 계열) */
  .btn-export {
  background: linear-gradient(135deg, #28a745, #20c997);
    }

    /* 불러오기 버튼 (파란색 계열, 혹은 대안 색상들) */
    .btn-import {
      background: linear-gradient(135deg, #0055ff, #0099ff);
    }

    /* 대안 색상 경우의 수
       - 보라색 계열: linear-gradient(135deg, #6f42c1, #b37feb);
       - 주황색 계열: linear-gradient(135deg, #fd7e14, #ffa94d);
       - 청록색 계열: linear-gradient(135deg, #20c997, #12b886);
    */

    .btn-export:hover, .btn-import:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    }

    .btn-export i, .btn-import i {
      font-size: 14px;
    }

     .quick-link-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 85, 255, 0.4);
    }

    .quick-link-btn svg {
      width: 15px;
      height: 15px;
    }


    .confirm-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      transition: background-color 0.3s ease;
    }

    .confirm-dialog.show {
      background: rgba(0, 0, 0, 0.5);
    }

    .confirm-dialog.show .confirm-content {
      transform: scale(1) translateY(0);
      opacity: 1;
    }

    .confirm-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    .download-btn {
      position: absolute;
      top: 8px;
      left: 8px;
      z-index: 20;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      border: none;
      border-radius: 6px;
      width: 32px;
      height: 32px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(40, 167, 69, 0.3);
      transition: all 0.2s ease;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(40, 167, 69, 0.4);
    }

    .download-btn svg {
      width: 16px;
      height: 16px;
    }

    .frame {
      width: 100%;
      height: 420px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      background: var(--frame-bg)
    }

    .frame img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 0.3s ease;
    }

    .frame img.hidden {
      opacity: 0
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0);
      transition: background-color 0.3s ease;
    }

    .modal.show {
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal.show .modal-content {
      transform: scale(1) translateY(0);
      opacity: 1;
    }

    .modal h3 {
      margin-top: 0;
      color: var(--accent);
      text-align: center;
    }

    .form-group {
      margin: 15px 0;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--text-color);
    }

    .form-row {
      display: flex;
      gap: 10px;
    }

    .form-row input {
      flex: 1;
    }

    .form-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 14px;
      box-sizing: border-box;
    }

    .form-group input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #0044cc;
    }

    .btn-secondary {
      background: #ccc;
      color: #333;
    }

    .btn-secondary:hover {
      background: #bbb;
    }

    .preview-image {
      max-width: 100%;
      height: 200px;
      object-fit: contain;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin: 10px 0;
    }

    footer {
      margin-top: 40px;
      text-align: center;
      font-size: 14px;
      color: var(--text-color);
      padding-bottom: 60px;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
      font-weight: bold;
    }

    .error {
      color: #ff4444;
      font-size: 14px;
    }
  </style>
</head>

<body>
<!-- 정보 버튼 -->
<button id="infoBtn" class="info-btn" title="사이트 이용 안내">
  <i class="fa-solid fa-circle-info"></i>
</button>

<div id="serverStatus" class="server-status">
  <div class="status-light-wrapper">
    <div class="status-light"></div>
  </div>
  <span class="status-text">확인 중...</span>
  <div id="customTooltip" class="custom-tooltip">서버 상태 확인 중...</div>
</div>

<!-- 정보 모달 -->
<div id="infoModal" class="info-modal">
  <div class="modal-content">
    <h3>사이트 이용 안내</h3>
    <div class="info-body">
      <h2 id="second-heading">이용 방법</h2>
      1. 감시하고 싶은 타일 좌표(Tl X, Tl Y)를 입력합니다. <br>⠀ 타일 좌표를 알아내기 위해 <a href="https://gall.dcinside.com/mgallery/board/view/?id=wplacelive&no=1204&search_head=30&page=1" target="_blank">블루 마블</a> 계열의 플러그인이 필요합니다.<br>
      2. 미리보기를 눌러 이미지가 올바르게 표시되는지 확인합니다.<br>
      3. 픽셀 좌표(Px X, Px Y)와 확대 비율 등을 입력한 뒤 추가합니다.<br>⠀ 필요에 따라 좌표를 미세조정해 작품을 정렬하세요.<br>
      4. 새로고침 간격을 조정해 자동 갱신 주기를 설정하세요.<br>
      5. 원하는 만큼 지점을 추가해 감시할 수 있습니다.<br>
      6. 내보내기 버튼을 눌러 현재 설정을 JSON 파일로 저장할 수 있습니다.<br>
      7. 불러오기 버튼을 눌러 이전에 저장한 JSON 파일을 불러올 수 있습니다.<br>
      8. 다크모드는 오른쪽 상단 해/달 아이콘으로 변경 가능합니다.<br>

      <h2><strong>문제 해결</strong></h2>
      <strong>- 이미지가 안뜨는데?</strong><br>다수의 이미지를 짧은 시간에 불러오려고 할때, Rate Limit에 걸릴 수 있습니다. 이 경우 새로고침 간격을 늘리고 잠시 기다렸다가 다시 시도해 보세요.<br>또는, <a href="https://wplace.instatus.com/" target="_blank">여기에서</a> 서버 상태를 확인해보세요.<br>
      <strong>- 타일 이미지가 씹창나고 꼬인것 같은데?</strong><br> 버그일 가능성이 큽니다. 기타란의 버그 신고 방법을 참고해 신고해 주세요.<br>

      <h2><strong>기타</strong></h2>
      <strong>- 버그 찾았다!</strong><br>
      축하드립니다. 버그를 찾으셨군요. 페이지 하단의 디스코드 링크 및 유저명을 참고하여 신고해주세요. 또는, <a href="https://github.com/wplaceBackend/wplaceBackend.github.io" target="_blank">깃헙</a>에 신고해주셔도 됩니다. <br>
      <strong>- 나 코딩 좀 해봤는데, 이거 더 개선할 수 있을 것 같음</strong><br>
      감사합니다. 깃헙 저장소를 이용하시거나 디스코드로 와주세요. 적극 검토 하겠습니다.<br>
      <strong>- 이거 왜 html, css, js 다 한곳에 모아놓음?</strong><br>
      AI한테 물어보기 편하고, 배포하기도 편합니다. 특히 다 나눠져 있으면 AI 파일 업로드 횟수가 많아져서 비효율적이거든요.<br>
    </div>
    <div class="modal-buttons">
      <button id="infoClose" class="btn btn-primary">확인</button>
    </div>
  </div>
</div>

  <div class="wrap">
    <!-- 바로가기 스타일의 새 버튼 -->
<a href="https://wplacebackend.github.io/" target="_blank" class="quick-link-btn" title="주요 거점 감시기 열기">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" fill="currentColor"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 32C64 14.3 49.7 0 32 0S0 14.3 0 32L0 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-121.6 62.7-18.8c41.9-12.6 87.1-8.7 126.2 10.9 42.7 21.4 92.5 24 137.2 7.2l37.1-13.9c12.5-4.7 20.8-16.6 20.8-30l0-247.7c0-23-24.2-38-44.8-27.7l-11.8 5.9c-44.9 22.5-97.8 22.5-142.8 0-36.4-18.2-78.3-21.8-117.2-10.1L64 54.4 64 32z"/></svg>
  주요 거점 감시하러 가기
</a>

     <button class="dark-mode-toggle" id="darkModeToggle" title="다크모드 전환">
       <svg id="sunIcon" viewBox="0 0 24 24" fill="currentColor">
         <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.591a.75.75 0 101.06 1.06l1.591-1.591zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.591-1.591a.75.75 0 10-1.06 1.06l1.591 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.591a.75.75 0 001.06 1.06l1.591-1.591zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06L6.166 5.106a.75.75 0 00-1.06 1.06l1.591 1.591z"/>
    </svg>
    <svg id="moonIcon" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
      <path d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z"/>
    </svg>
  </button>
    
    <header>
      <h1>Wplace 맞춤 지점 감시기</h1>
      <p>감시하고 싶은 지점을 추가하고 새로고침 시간을 설정할 수 있습니다.</p>
    </header>

<div class="controls">
  <label for="interval">새로고침 간격(초):</label>
  <input type="number" id="interval" value="30" min="1" />
  
  <button id="exportBtn" class="btn-export">
    <i class="fa-solid fa-download"></i> 내보내기
  </button>
  <button id="importBtn" class="btn-import">
    <i class="fa-solid fa-cloud-arrow-up"></i> 불러오기
  </button>
  <input type="file" id="importFile" accept=".json" style="display:none;">
</div>

    <main class="grid" id="mainGrid">
      <div class="card add-card" id="addCard">
        <svg class="add-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>
        </svg>
        <div class="add-text">감시 지점 추가</div>
      </div>
    </main>
  </div>

  <!-- 모달 -->
  <div id="addModal" class="modal">
    <div class="modal-content">
      <h3>감시 지점 추가</h3>
      
      <div class="form-group">
        <label>작품이 속해 있는 타일 좌표를 입력해주세요.</label>
        <div class="form-row">
          <input type="number" id="tileX" placeholder="Tl X" required>
          <input type="number" id="tileY" placeholder="Tl Y" required>
        </div>
        <div class="error" id="tileError"></div>
      </div>

      <div class="form-group">
        <button type="button" class="btn btn-primary" id="loadPreview">이미지 미리보기</button>
      </div>

      <div id="previewSection" style="display: none;">
        <div class="form-group">
          <img id="previewImage" class="preview-image" alt="미리보기">
        </div>

        <div class="form-group">
          <label>작품의 픽셀 좌표, 확대 비율, 최소 보장 폭(선택)을 입력해주세요.</label>
          <div class="form-row">
            <input type="number" id="pixelX" placeholder="Px X" required>
            <input type="number" id="pixelY" placeholder="Px Y" required>
          </div>
          <div class="form-row">
            <input type="number" id="baseScale" placeholder="확대 비율" step="0.1" required>
            <input type="number" id="minWidth" placeholder="최소 보장 폭 (선택)" step="1">
          </div>
          <div class="error" id="pixelError"></div>
        </div>

        <div class="form-group">
          <label for="cardName">지점 이름:</label>
          <input type="text" id="cardName" placeholder="지점 이름을 입력하세요" required>
          <div class="error" id="nameError"></div>
        </div>

        <div class="form-group">
          <label for="shareLink">장소 바로가기 링크 (선택):</label>
          <input type="url" id="shareLink" placeholder="https://wplace.live/?lat=...">
          <div class="error" id="linkError"></div>
        </div>
      </div>

      <div class="modal-buttons">
        <button type="button" class="btn btn-secondary" id="cancelBtn">취소</button>
        <button type="button" class="btn btn-primary" id="addBtn" style="display: none;">추가</button>
      </div>
    </div>
  </div>

  <footer>
    만든 놈 - <a href="discord://-/users/1143199445035536404">OrangeBlue</a> <br> 디스코드 @orangeblue2336
  </footer>

  <script>
    const serverStatusElement = document.getElementById('serverStatus');
    const statusLight = serverStatusElement.querySelector('.status-light');
    const statusText = serverStatusElement.querySelector('.status-text');
    const customTooltip = document.getElementById('customTooltip');
    const statusLightWrapper = serverStatusElement.querySelector('.status-light-wrapper');

    let intervalSec = 30;
    let timer;
    let cardCounter = 0;
    let monitorCards = [];
    let refreshTimer = null;

async function checkServerStatus() {
  playPulseAnimation(); // 애니메이션 실행 코드 추가
  
  // AbortController를 사용해 5초 타임아웃 설정
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 5000); // 5초

  try {
    // wplace.live의 favicon.ico는 용량이 작고 캐시 정책이 짧아 확인용으로 적합합니다.
    // Date.now()를 쿼리로 추가하여 캐시를 무시하고 항상 새로 요청합니다.
    const response = await fetch('https://wplace-cors-proxy.snackcandy105.workers.dev/?url=https://backend.wplace.live/files/s0/tiles/1774/795.png?t=' + Date.now( ), {
      method: 'HEAD', // HEAD 메소드로 요청하면 본문 없이 헤더만 받아와 빠릅니다.
      signal: controller.signal,
      cache: 'no-store' // 캐시 사용 안함
    });

    clearTimeout(timeoutId);

    if (response.ok) {
      // 요청 성공 (200-299 상태 코드)
      updateStatus('ok', '서버 원활' , `정상 응답 (코드: ${response.status})`);
    } else {
      // 서버는 응답했으나, 정상적인 상태 코드가 아님
      updateStatus('error', '접속 불가', `서버 오류 (코드: ${response.status})`);
    }
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      // 요청 시간 초과
      updateStatus('error', '접속 불가', '응답 시간 초과');
    } else {
      // 네트워크 오류 등 기타 문제
      updateStatus('unknown', '확인 불가', '네트워크 오류');
    }
  }
}

function updateStatus(status, mainText, tooltipText) {
  const isChanging = !serverStatusElement.classList.contains(status);

  serverStatusElement.className = 'server-status ' + status;
  statusText.textContent = mainText;
  customTooltip.textContent = `백엔드 서버 상태: ${tooltipText}`; // 커스텀 툴팁 내용 업데이트

  // 상태가 변경될 때는 애니메이션을 건너뛰고,
  // 상태가 유지될 때만 애니메이션을 재생합니다.
  if (!isChanging) {
    playPulseAnimation();
  }
}

function playPulseAnimation() {
  // 기존 애니메이션 요소 제거
  const existingPulses = statusLightWrapper.querySelectorAll('.pulse');
  existingPulses.forEach(p => p.remove());

  // 현재 상태 표시등의 색상 가져오기
  const currentColor = window.getComputedStyle(statusLight).backgroundColor;

  // 2번의 펄스 효과 생성
  for (let i = 0; i < 2; i++) {
    setTimeout(() => {
      const pulse = document.createElement('div');
      pulse.className = 'pulse';
      pulse.style.color = currentColor; // 애니메이션 색상 설정
      statusLightWrapper.appendChild(pulse);
      
      // 애니메이션이 끝나면 DOM에서 제거
      pulse.addEventListener('animationend', () => {
        pulse.remove();
      });
    }, i * 300); // 0.3초 간격으로 실행
  }
}

// 1분에 한 번씩 서버 상태 확인
setInterval(checkServerStatus, 60000); 
// 페이지 로드 시 즉시 한 번 실행
checkServerStatus();


    // 로컬 스토리지에서 데이터 로드
    function loadFromStorage() {
      try {
        const saved = JSON.parse(localStorage.getItem('wplace-monitor-cards') || '[]');
        const savedInterval = parseInt(localStorage.getItem('wplace-monitor-interval') || '30');
        
        intervalSec = savedInterval;
        document.getElementById('interval').value = intervalSec;
        
        saved.forEach(cardData => {
          createCard(cardData);
        });
        
        if (monitorCards.length > 0) {
          applyFocusAll();
        }
      } catch (e) {
        console.error('Failed to load from storage:', e);
      }
    }

    // 로컬 스토리지에 저장
    function saveToStorage() {
      try {
        const cardsData = monitorCards.map(card => ({
          id: card.id,
          name: card.name,
          tileX: card.tileX,
          tileY: card.tileY,
          cx: card.cx,
          cy: card.cy,
          baseScale: card.baseScale,
          minWidth: card.minWidth,
          shareLink: card.shareLink
        }));
        
        localStorage.setItem('wplace-monitor-cards', JSON.stringify(cardsData));
        localStorage.setItem('wplace-monitor-interval', intervalSec.toString());
      } catch (e) {
        console.error('Failed to save to storage:', e);
      }
    }

    function refreshImages(imgElements) {
      imgElements.forEach(img => {
        if (!img || !img.dataset.src) return;
        
        const base = img.dataset.src;
        const url = base + (base.includes('?') ? '&' : '?') + 't=' + Date.now();

        const preload = new Image();
        preload.onload = () => {
          img.classList.add('hidden');
          setTimeout(() => {
            img.src = url;
            img.classList.remove('hidden');
          }, 200);
        };
        preload.onerror = () => {
          console.warn('Failed to load image:', url);
        };
        preload.src = url;
      });
    }

    function refreshAll() {
      const imgs = monitorCards.map(card => document.getElementById(`img-${card.id}`)).filter(Boolean);
      refreshImages(imgs);
    }

    function startInterval() {
      clearInterval(timer);
      timer = setInterval(refreshAll, intervalSec * 1000);
    }

    function focusImage(img, cx, cy, baseScale, minWidth = 0) {
      if (!img) return;
      
      const frame = img.parentElement;
      const frameW = frame.clientWidth;
      const frameH = frame.clientHeight;

      // Use fixed dimensions like in ready.html
      const origW = 1000;
      const origH = 1000;

      const scaleX1 = frameW / (2 * cx);
      const scaleX2 = frameW / (2 * (origW - cx));
      const scaleY1 = frameH / (2 * cy);
      const scaleY2 = frameH / (2 * (origH - cy));

      const coverScale = Math.max(scaleX1, scaleX2, scaleY1, scaleY2);
      const baseOrCover = baseScale ?? coverScale;

      let candidateScale = baseOrCover;
      if (minWidth && minWidth > 0) {
        const capByROI = frameW / minWidth;
        candidateScale = Math.min(candidateScale, capByROI);
      }

      const finalScale = candidateScale;
      const scaledW = origW * finalScale;
      const scaledH = origH * finalScale;

      let offsetX = frameW / 2 - cx * finalScale;
      let offsetY = frameH / 2 - cy * finalScale;

      img.style.width = `${scaledW}px`;
      img.style.height = `${scaledH}px`;
      img.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    }

    function applyFocusAll() {
      monitorCards.forEach(card => {
        const img = document.getElementById(`img-${card.id}`);
        if (img) {
          focusImage(img, card.cx, card.cy, card.baseScale, card.minWidth);
        }
      });
    }

    function createCard(cardData) {
      const maxId = monitorCards.length > 0
      ? Math.max(...monitorCards.map(c => c.id))
      : 0;
    const cardId = (cardData.id !== undefined) ? cardData.id : maxId + 1;
      
      const cardElement = document.createElement('article');
      cardElement.className = 'card';
      cardElement.id = `card-${cardId}`;
      
      const imageUrl = `https://backend.wplace.live/files/s0/tiles/${cardData.tileX}/${cardData.tileY}.png`;
      
      let buttonsHtml = '';
      if (cardData.shareLink) {
        buttonsHtml += `<a href="${cardData.shareLink}" target="_blank" class="goto-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
          </svg>
          바로 가기
        </a>`;
      }
      
      cardElement.innerHTML = `
        <div class="card-header">
          <button class="download-btn" onclick="confirmDownload(${cardId})">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
          </button>
          <div class="meta">
            <strong>${cardData.name}</strong>
          </div>
          <div class="card-buttons">
            ${buttonsHtml}
            <button class="edit-btn" onclick="editCard(${cardId})">수정</button>
            <button class="delete-btn" onclick="confirmDelete(${cardId})">삭제</button>
          </div>
        </div>
        <div class="frame" id="frame-${cardId}">
          <img id="img-${cardId}" data-src="${imageUrl}" alt="${cardData.name}" />
        </div>
      `;
      
      const addCard = document.getElementById('addCard');
      addCard.parentNode.insertBefore(cardElement, addCard);
      
      const cardObj = {
        id: cardId,
        name: cardData.name,
        tileX: cardData.tileX,
        tileY: cardData.tileY,
        cx: cardData.cx,
        cy: cardData.cy,
        baseScale: cardData.baseScale,
        minWidth: cardData.minWidth,
        shareLink: cardData.shareLink || null
      };
      
      monitorCards.push(cardObj);
      
      // 이미지 로드
      const img = document.getElementById(`img-${cardId}`);
      img.onload = () => {
        focusImage(img, cardObj.cx, cardObj.cy, cardObj.baseScale, cardObj.minWidth);
      };
      refreshImages([img]);
      
      saveToStorage();
      return cardObj;
    }

    function confirmDownload(cardId) {
      const card = monitorCards.find(c => c.id === cardId);
      if (!card) return;

      const confirmDialog = document.createElement('div');
      confirmDialog.className = 'confirm-dialog';
      confirmDialog.innerHTML = `
        <div class="confirm-content">
          <h3>이미지 다운로드</h3>
          <p>새 탭에서 "${card.name}" 타일의 원본 이미지가 열립니다.<br>
이미지를 우클릭 → "다른 이름으로 저장"을 눌러 저장 후,<br>
외부 프로그램으로 잘라 테러 방지 도안을 제작할 수 있습니다.<br><br>
새 탭에서 계속 진행하시겠습니까?</p>
          <div class="confirm-buttons">
            <button class="btn btn-secondary" onclick="cancelDownload()">취소</button>
            <button class="btn btn-primary" onclick="executeDownload(${cardId})">네</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(confirmDialog);
      
      // 애니메이션 적용
      setTimeout(() => {
        confirmDialog.classList.add('show');
      }, 10);
    }

    function cancelDownload() {
      const confirmDialog = document.querySelector('.confirm-dialog');
      if (confirmDialog) {
        confirmDialog.classList.remove('show');
        setTimeout(() => {
          confirmDialog.remove();
        }, 300);
      }
    }

    function executeDownload(cardId) {
      const card = monitorCards.find(c => c.id === cardId);
      const img = document.getElementById(`img-${cardId}`);
      const frame = document.getElementById(`frame-${cardId}`);
      
      if (!card || !img || !frame) return;
      
      // Canvas 생성하여 현재 보이는 이미지 영역 캡처
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      const frameRect = frame.getBoundingClientRect();
      canvas.width = frame.clientWidth;
      canvas.height = frame.clientHeight;
      
      // 배경색 설정
      ctx.fillStyle = 'transparent';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 이미지 로드 후 그리기
      const tempImg = new Image();
      tempImg.crossOrigin = 'anonymous';
      
      tempImg.onload = () => {
        try {
          // Use fixed dimensions like in the focusImage function
          const origW = 1000;
          const origH = 1000;

          const frameW = frame.clientWidth;
          const frameH = frame.clientHeight;
          const cx = card.cx;
          const cy = card.cy;
          const baseScale = card.baseScale ?? 1;
          const minWidth = card.minWidth || 0;

          const scaleX1 = frameW / (2 * cx);
          const scaleX2 = frameW / (2 * (origW - cx));
          const scaleY1 = frameH / (2 * cy);
          const scaleY2 = frameH / (2 * (origH - cy));

          const coverScale = Math.max(scaleX1, scaleX2, scaleY1, scaleY2);
          const baseOrCover = (baseScale == null) ? coverScale : baseScale;
          let candidateScale = baseOrCover;
          if (minWidth && minWidth > 0) {
            const capByROI = frameW / minWidth;
            candidateScale = Math.min(candidateScale, capByROI);
          }

          const finalScale = candidateScale;
          const scaledW = origW * finalScale;
          const scaledH = origH * finalScale;
          const offsetX = frameW / 2 - cx * finalScale;
          const offsetY = frameH / 2 - cy * finalScale;

          // Determine the source rectangle in the original image that maps to the canvas
          const srcX = Math.max(0, (-offsetX) / finalScale);
          const srcY = Math.max(0, (-offsetY) / finalScale);
          const srcW = Math.min(origW - srcX, canvas.width / finalScale);
          const srcH = Math.min(origH - srcY, canvas.height / finalScale);

          // Draw that portion stretched to the canvas size
          ctx.drawImage(tempImg, srcX, srcY, srcW, srcH, 0, 0, canvas.width, canvas.height);

          try {
            const link = document.createElement('a');
            link.download = `${card.name}_확대이미지.png`;
            link.href = canvas.toDataURL();
            link.click();
            cancelDownload();
          } catch (err) {
            console.warn('Canvas toDataURL failed (CORS). Falling back to opening original image.', err);
            const fallbackUrl = tempImg.src || img.dataset.src + '?t=' + Date.now();
            window.open(fallbackUrl, '_blank');
            cancelDownload();
          }
        } catch (err) {
          console.error('Download error:', err);
          alert('이미지 다운로드에 실패했습니다.');
          cancelDownload();
        }
      };
      
      tempImg.onerror = () => {
        window.open(img.dataset.src + '?t=' + Date.now(), '_blank');
        cancelDownload();
      };
      
      tempImg.src = img.dataset.src + '?t=' + Date.now();
    }
      
    function confirmDelete(cardId) {
      const card = monitorCards.find(c => c.id === cardId);
      if (!card) return;

      const confirmDialog = document.createElement('div');
      confirmDialog.className = 'confirm-dialog';
      confirmDialog.innerHTML = `
        <div class="confirm-content">
          <h3>삭제 확인</h3>
          <p>"${card.name}" 지점을 정말로 삭제하시겠습니까?</p>
          <div class="confirm-buttons">
            <button class="btn btn-secondary" onclick="cancelDelete()">취소</button>
            <button class="btn btn-primary" onclick="executeDelete(${cardId})">네</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(confirmDialog);
      
      setTimeout(() => {
        confirmDialog.classList.add('show');
      }, 10);
    }

    function cancelDelete() {
      const confirmDialog = document.querySelector('.confirm-dialog');
      if (confirmDialog) {
        confirmDialog.classList.remove('show');
        setTimeout(() => {
          confirmDialog.remove();
        }, 300);
      }
    }

    function executeDelete(cardId) {
      deleteCard(cardId);
      cancelDelete();
    }

    function deleteCard(cardId) {
      const cardElement = document.getElementById(`card-${cardId}`);
      if (cardElement) {
        cardElement.remove();
      }
      
      monitorCards = monitorCards.filter(card => card.id !== cardId);
      saveToStorage();
    }

    function editCard(cardId) {
      const card = monitorCards.find(c => c.id === cardId);
      if (!card) return;

      // 모달 열기
      modal.style.display = 'block';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
      
      // 기존 데이터 채우기
      document.getElementById('tileX').value = card.tileX;
      document.getElementById('tileY').value = card.tileY;
      document.getElementById('pixelX').value = card.cx;
      document.getElementById('pixelY').value = card.cy;
      document.getElementById('baseScale').value = card.baseScale;
      document.getElementById('minWidth').value = card.minWidth || '';
      document.getElementById('cardName').value = card.name;
      document.getElementById('shareLink').value = card.shareLink || '';
      
      // 미리보기 이미지 로드
      const imageUrl = `https://backend.wplace.live/files/s0/tiles/${card.tileX}/${card.tileY}.png`;
      const previewImg = document.getElementById('previewImage');
      previewImg.src = imageUrl;
      document.getElementById('previewSection').style.display = 'block';
      
      // 버튼 텍스트 변경
      document.getElementById('addBtn').textContent = '수정';
      document.getElementById('addBtn').style.display = 'inline-block';
      document.getElementById('addBtn').dataset.editId = cardId;
      
      // 모달 제목 변경
      document.querySelector('.modal h3').textContent = '감시 지점 수정';
      
      clearErrors();
    }

    // 모달 관련
    const modal = document.getElementById('addModal');
    const addCard = document.getElementById('addCard');
    const cancelBtn = document.getElementById('cancelBtn');
    const loadPreviewBtn = document.getElementById('loadPreview');
    const addBtn = document.getElementById('addBtn');

    addCard.addEventListener('click', () => {
  modal.style.display = 'block';
  setTimeout(() => {
    modal.classList.add('show');
  }, 10);
  resetModal();
});

cancelBtn.addEventListener('click', () => {
  modal.classList.remove('show');
  setTimeout(() => {
    modal.style.display = 'none';
  }, 300);
});


        function resetModal() {
      document.getElementById('tileX').value = '';
      document.getElementById('tileY').value = '';
      document.getElementById('pixelX').value = '';
      document.getElementById('pixelY').value = '';
      document.getElementById('baseScale').value = '';
      document.getElementById('minWidth').value = '';
      document.getElementById('cardName').value = '';
      document.getElementById('shareLink').value = '';
      document.getElementById('previewSection').style.display = 'none';
      document.getElementById('addBtn').style.display = 'none';
      document.getElementById('addBtn').textContent = '추가';
      document.getElementById('addBtn').removeAttribute('data-edit-id');
      document.querySelector('.modal h3').textContent = '감시 지점 추가';
      clearErrors();
    }

    function clearErrors() {
      document.querySelectorAll('.error').forEach(el => el.textContent = '');
    }

    loadPreviewBtn.addEventListener('click', () => {
      clearErrors();
      
      const tileX = document.getElementById('tileX').value.trim();
      const tileY = document.getElementById('tileY').value.trim();
      
      if (!tileX || !tileY) {
        document.getElementById('tileError').textContent = 'Tl X와 Tl Y는 필수 입력 항목입니다.';
        return;
      }
      
      const imageUrl = `https://backend.wplace.live/files/s0/tiles/${tileX}/${tileY}.png`;
      const previewImg = document.getElementById('previewImage');
      
      previewImg.src = imageUrl;
      previewImg.onload = () => {
        document.getElementById('previewSection').style.display = 'block';
        document.getElementById('addBtn').style.display = 'inline-block';
      };
      
      previewImg.onerror = () => {
        document.getElementById('tileError').textContent = '이미지를 로드할 수 없습니다. 좌표를 확인해주세요.';
      };
    });

    addBtn.addEventListener('click', () => {
      clearErrors();
      
      const tileX = document.getElementById('tileX').value.trim();
      const tileY = document.getElementById('tileY').value.trim();
      const pixelX = document.getElementById('pixelX').value.trim();
      const pixelY = document.getElementById('pixelY').value.trim();
      const baseScale = document.getElementById('baseScale').value.trim();
      const minWidth = document.getElementById('minWidth').value.trim();
      const cardName = document.getElementById('cardName').value.trim();
      const shareLink = document.getElementById('shareLink').value.trim();
      const editId = addBtn.dataset.editId;
      
      let hasError = false;
      
      if (!tileX || !tileY) {
        document.getElementById('tileError').textContent = 'Tl X와 Tl Y는 필수 입력 항목입니다.';
        hasError = true;
      }
      
      if (!pixelX || !pixelY || !baseScale) {
        document.getElementById('pixelError').textContent = 'Px X, Px Y, 확대 비율은 필수 입력 항목입니다.';
        hasError = true;
      }
      
      if (!cardName) {
        document.getElementById('nameError').textContent = '지점 이름은 필수 입력 항목입니다.';
        hasError = true;
      }
      
      // 링크 유효성 검증
      if (shareLink && !shareLink.startsWith('https://wplace.live')) {
        document.getElementById('linkError').textContent = '올바른 링크가 아닙니다. https://wplace.live 로 시작하는 링크를 입력해주세요.';
        hasError = true;
      }
      
      if (hasError) return;
      
      const cardData = {
        name: cardName,
        tileX: parseInt(tileX),
        tileY: parseInt(tileY),
        cx: parseInt(pixelX),
        cy: parseInt(pixelY),
        baseScale: parseFloat(baseScale),
        minWidth: minWidth ? parseInt(minWidth) : 0,
        shareLink: shareLink || null
      };
      
      if (editId) {
        // 수정 모드: 기존 카드 데이터를 업데이트하고 DOM을 수정
        const cardId = parseInt(editId);
        const existingIndex = monitorCards.findIndex(c => c.id === cardId);
        if (existingIndex !== -1) {
          // update data model
          monitorCards[existingIndex] = {
            id: cardId,
            name: cardData.name,
            tileX: cardData.tileX,
            tileY: cardData.tileY,
            cx: cardData.cx,
            cy: cardData.cy,
            baseScale: cardData.baseScale,
            minWidth: cardData.minWidth,
            shareLink: cardData.shareLink || null
          };

          // update DOM elements without changing position
          const img = document.getElementById(`img-${cardId}`);
          const frame = document.getElementById(`frame-${cardId}`);
          const cardEl = document.getElementById(`card-${cardId}`);
          if (img) {
            const imageUrl = `https://backend.wplace.live/files/s0/tiles/${cardData.tileX}/${cardData.tileY}.png`;
            img.dataset.src = imageUrl;
            img.src = imageUrl + '?t=' + Date.now();
            img.onload = () => {
              focusImage(img, cardData.cx, cardData.cy, cardData.baseScale, cardData.minWidth);
            };
          }

          if (cardEl) {
            // update title
            const titleEl = cardEl.querySelector('.meta strong');
            if (titleEl) titleEl.textContent = cardData.name;
            // update goto link if present
            const gotoContainer = cardEl.querySelector('.card-buttons');
            const existingGoto = gotoContainer.querySelector('.goto-btn');
            if (existingGoto) existingGoto.remove();
            
            if (cardData.shareLink) {
              const gotoBtn = document.createElement('a');
              gotoBtn.href = cardData.shareLink;
              gotoBtn.target = '_blank';
              gotoBtn.className = 'goto-btn';
              gotoBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
              </svg>바로 가기`;
              gotoContainer.insertBefore(gotoBtn, gotoContainer.firstChild);
            }
          }

          saveToStorage();
        }
      } else {
        // 추가 모드
        createCard(cardData);
      }
      
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
      
      // 포커스 적용
      setTimeout(() => {
        applyFocusAll();
      }, 100);
    });

    // 새로고침 간격 변경
    document.getElementById('interval').addEventListener('change', e => {
      intervalSec = parseInt(e.target.value, 10) || 5;
      startInterval();
      saveToStorage();
    });

    // 창 크기 변경 시 포커스 재적용
    window.addEventListener('resize', applyFocusAll);

    // 페이지 언로드 시 타이머 정리
    window.addEventListener('beforeunload', () => {
      clearInterval(timer);
    });
   
    // 다크모드 관련 코드
    function initDarkMode() {
      const darkModeToggle = document.getElementById('darkModeToggle');
      const sunIcon = document.getElementById('sunIcon');
      const moonIcon = document.getElementById('moonIcon');
  
    // 저장된 테마 불러오기
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateIcons(savedTheme);
  
    darkModeToggle.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

    // 회전 애니메이션 추가
    darkModeToggle.classList.add('rotating');
    setTimeout(() => {
      darkModeToggle.classList.remove('rotating');
    }, 300);
    
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    updateIcons(newTheme);
  });
  
  function updateIcons(theme) {
    if (theme === 'dark') {
      sunIcon.style.display = 'none';
      moonIcon.style.display = 'block';
    } else {
      sunIcon.style.display = 'block';
      moonIcon.style.display = 'none';
    }
  }
}

// ===== JSON 내보내기 / 불러오기 기능 =====

// 내보내기
document.getElementById("exportBtn").addEventListener("click", () => {
  const exportData = {
    interval: intervalSec,
    cards: monitorCards.map(c => ({
      id: c.id,
      name: c.name,
      tileX: c.tileX,
      tileY: c.tileY,
      cx: c.cx,
      cy: c.cy,
      baseScale: c.baseScale,
      minWidth: c.minWidth,
      shareLink: c.shareLink
    }))
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "wplace-monitor-save.json";
  a.click();
  URL.revokeObjectURL(url);
});

// 불러오기 버튼 클릭 시 파일 선택창 열기
document.getElementById("importBtn").addEventListener("click", () => {
  document.getElementById("importFile").click();
});

// JSON 파일 읽기 및 적용
document.getElementById("importFile").addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);
      if (!imported.cards) {
        alert("올바르지 않은 JSON 파일입니다.");
        return;
      }

    // ⚠️ 경고 문구 추가
    const proceed = confirm("불러오기를 진행하면 기존 데이터가 모두 덮어씌워집니다.\n계속하시겠습니까?");
    if (!proceed) return;

      // 기존 카드 제거 후 로드
      monitorCards.forEach(c => {
        const el = document.getElementById(`card-${c.id}`);
        if (el) el.remove();
      });
      monitorCards = []; // 배열 초기화
      
      let maxId = 0;
      imported.cards.forEach(card => {
         createCard(card);
         if (card.id > maxId) maxId = card.id;
      });
      cardCounter = maxId;
      intervalSec = imported.interval || 30;
      document.getElementById("interval").value = intervalSec;
      saveToStorage();
      applyFocusAll();

      // 기존 새로고침 루프 초기화 후 다시 시작
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(() => {
        refreshAll();
      }, intervalSec * 1000);


      alert("JSON 데이터를 성공적으로 불러왔습니다.\n페이지가 새로고침됩니다.");
      location.reload();
    } catch (err) {
      console.error(err);
      alert("JSON 파일을 불러오는 중 오류가 발생했습니다.");
    }
  };
  reader.readAsText(file);
});

// 정보 모달
const infoBtn = document.getElementById("infoBtn");
const infoModal = document.getElementById("infoModal");
const infoClose = document.getElementById("infoClose");

infoBtn.addEventListener("click", () => {
  infoModal.style.display = "block";
  setTimeout(() => {
    infoModal.classList.add("show");
  }, 10);
});

infoClose.addEventListener("click", () => {
  infoModal.classList.remove("show");
  setTimeout(() => {
    infoModal.style.display = "none";
  }, 300);
});






    // 초기 로드
    initDarkMode();
    loadFromStorage();
    startInterval();
  </script>
</body>

</html>
